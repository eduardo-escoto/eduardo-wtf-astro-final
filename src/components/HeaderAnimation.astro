<script>
  import { $pointState, $animationInterval } from '@/store'

  import { type AnimationPoint2D } from '@/animation/types'
  import { Vector2D } from '@/animation/vectors'
  // import { Vector2D } from '@/animation/vectors'
  import { Point2D } from '@/animation/points'

  // import random from '@stdlib/random/base'
  // import { contentObservable } from 'node_modules/astro/dist/content/utils'

  const ANIMATION_CONSTANTS = {
    REFRESH_RATE: 120, // in hz
    N_POINTS: 20,
  }

  // const normal = random.boxMuller.factory()

  interface ContextReturn {
    canvas: HTMLCanvasElement
    context: CanvasRenderingContext2D
  }

  function handleResize() {
    const canvasContainer = document.getElementById('animation-container') as HTMLDivElement
    const canvas = document.getElementById('animation-canvas') as HTMLCanvasElement

    canvas.width = canvasContainer.offsetWidth
    canvas.height = canvasContainer.offsetHeight

    renderCurrentState()
  }

  function createPoint(
    canvas: HTMLCanvasElement,
    context: CanvasRenderingContext2D,
    point: AnimationPoint2D
  ) {
    context.beginPath()
    context.arc(
      canvas.width * point.position.x,
      canvas.height * point.position.y,
      point.radius_len,
      0,
      2 * Math.PI
    )

    context.strokeStyle = point.color.toHSLDefinitionString()
    context.fillStyle = point.color.toHSLDefinitionString()

    context.stroke()
    context.fill()
    context.closePath()
  }

  function getContext(): ContextReturn {
    const canvas = document.getElementById('animation-canvas') as HTMLCanvasElement
    const context = canvas.getContext('2d') || new CanvasRenderingContext2D()
    return { canvas, context }
  }

  function clearContext() {
    const { canvas, context } = getContext()
    context.reset()
  }

  function renderCurrentState() {
    const { canvas, context } = getContext()
    const points = $pointState.get()
    points.forEach((point: AnimationPoint2D) => {
      createPoint(canvas, context, point)
    })
  }

  function getNextState(): Array<AnimationPoint2D> {
    const { canvas } = getContext()
    const points = $pointState.get()
    const newPoints = points.map((point: AnimationPoint2D) => {
      const x_buff_offset = point.radius_len / canvas.width
      const y_buff_offset = point.radius_len / canvas.height
      const edgeBuffer = {
        left: x_buff_offset,
        right: 1 - x_buff_offset,
        top: y_buff_offset,
        bottom: 1 - y_buff_offset,
      }
      const nextVelocity = new Vector2D(point.velocity_vec.magnitude, point.velocity_vec.angle)
      const nextPosition = point.position.add(point.velocity_vec)

      if (nextPosition.x > edgeBuffer.right || nextPosition.x < edgeBuffer.left) {
        nextVelocity.angle = Math.PI - nextVelocity.angle
        if (nextPosition.x > edgeBuffer.right)
          nextPosition.x = 2 * edgeBuffer.right - nextPosition.x
        if (nextPosition.x < edgeBuffer.left)
          nextPosition.x = 2 * edgeBuffer.left - Math.abs(nextPosition.x)
      }

      if (nextPosition.y > edgeBuffer.bottom || nextPosition.y < edgeBuffer.top) {
        nextVelocity.angle = -nextVelocity.angle
        if (nextPosition.y > edgeBuffer.bottom)
          nextPosition.y = 2 * edgeBuffer.bottom - nextPosition.y
        if (nextPosition.y < edgeBuffer.top)
          nextPosition.y = 2 * edgeBuffer.top - Math.abs(nextPosition.y)
      }

      return new Point2D(point.radius_len, nextPosition, nextVelocity, point.color)
    })
    return newPoints
  }

  function updateState(state: Array<AnimationPoint2D>) {
    $pointState.set(state)
  }

  function animate() {
    clearContext()
    renderCurrentState()

    const state = getNextState()
    updateState(state)
  }

  function initAnimation() {
    const intervalSpeed = (1 / ANIMATION_CONSTANTS.REFRESH_RATE) * 1000 // converting refresh rate to ms
    let points: Array<AnimationPoint2D> = []

    for (let i = 0; i <= ANIMATION_CONSTANTS.N_POINTS; i++) {
      points = [...points, Point2D.RandomPointFactory()]
    }
    console.log(points)
    $pointState.set(points)

    handleResize()
    animate()

    $animationInterval.set(setInterval(() => animate(), intervalSpeed))
  }

  function pauseAnimation() {
    clearInterval($animationInterval.get())
  }

  function unPauseAnimation() {
    const intervalSpeed = (1 / ANIMATION_CONSTANTS.REFRESH_RATE) * 1000 // converting refresh rate to ms

    handleResize()
    $animationInterval.set(
      setInterval(() => {
        animate()
      }, intervalSpeed)
    )
  }

  document.addEventListener('astro:page-load', initAnimation, { once: true })
  document.addEventListener('astro:before-swap', pauseAnimation)
  document.addEventListener('astro:after-swap', unPauseAnimation)

  window.addEventListener('resize', handleResize)

  // TODO:
  // - collision detection against wall
  // - collision detection against other points
  // - reflection off of wall
  // - bounce off of other points
  // - utility functions for vector calculation
</script>

<div class="absolute top-0 -z-10 h-full w-full" id="animation-container">
  <canvas width="0" height="0" id="animation-canvas"></canvas>
</div>
